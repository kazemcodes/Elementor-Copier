<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clipboard Focus Test - Elementor Copier</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    h1 {
      color: #333;
      border-bottom: 3px solid #92003B;
      padding-bottom: 10px;
    }
    
    .test-section {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .test-section h2 {
      color: #92003B;
      margin-top: 0;
    }
    
    button {
      background: #92003B;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px;
    }
    
    button:hover {
      background: #750030;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .result {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    
    .result.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .result.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .result.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    .test-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 15px 0;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .stat-card {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #92003B;
    }
    
    .stat-card h3 {
      margin: 0 0 5px 0;
      font-size: 14px;
      color: #666;
    }
    
    .stat-card .value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }
    
    .log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .log-entry {
      margin: 2px 0;
    }
    
    .log-entry.success { color: #4ec9b0; }
    .log-entry.error { color: #f48771; }
    .log-entry.warning { color: #dcdcaa; }
    .log-entry.info { color: #9cdcfe; }
  </style>
</head>
<body>
  <h1>ðŸ§ª Clipboard Focus Test Suite</h1>
  <p>Test clipboard operations with focus management and retry logic (Task 13)</p>

  <div class="test-section">
    <h2>Test Statistics</h2>
    <div class="stats">
      <div class="stat-card">
        <h3>Total Tests</h3>
        <div class="value" id="totalTests">0</div>
      </div>
      <div class="stat-card">
        <h3>Successful</h3>
        <div class="value" id="successTests">0</div>
      </div>
      <div class="stat-card">
        <h3>Failed</h3>
        <div class="value" id="failedTests">0</div>
      </div>
      <div class="stat-card">
        <h3>Success Rate</h3>
        <div class="value" id="successRate">0%</div>
      </div>
    </div>
  </div>

  <div class="test-section">
    <h2>1. Basic Clipboard Write Test</h2>
    <p>Test basic clipboard write operation with focus management</p>
    <div class="test-controls">
      <button onclick="testBasicWrite()">Run Test</button>
      <button onclick="testBasicWriteUnfocused()">Test Without Focus</button>
    </div>
    <div id="basicWriteResult"></div>
  </div>

  <div class="test-section">
    <h2>2. Retry Logic Test</h2>
    <p>Test clipboard write with simulated focus issues and retry logic</p>
    <div class="test-controls">
      <button onclick="testRetryLogic()">Run Test</button>
      <button onclick="testMultipleRetries()">Test Multiple Retries</button>
    </div>
    <div id="retryResult"></div>
  </div>

  <div class="test-section">
    <h2>3. Fallback Strategies Test</h2>
    <p>Test alternative clipboard write strategies when focus fails</p>
    <div class="test-controls">
      <button onclick="testFallbackStrategies()">Run Test</button>
      <button onclick="testExecCommandFallback()">Test execCommand</button>
      <button onclick="testTextareaFallback()">Test Textarea</button>
    </div>
    <div id="fallbackResult"></div>
  </div>

  <div class="test-section">
    <h2>4. Stress Test</h2>
    <p>Test clipboard operations under various browser states</p>
    <div class="test-controls">
      <button onclick="testRapidWrites()">Rapid Writes (10x)</button>
      <button onclick="testLargeData()">Large Data Write</button>
      <button onclick="testConcurrentWrites()">Concurrent Writes</button>
    </div>
    <div id="stressResult"></div>
  </div>

  <div class="test-section">
    <h2>5. Read/Write Cycle Test</h2>
    <p>Test complete read/write cycle with focus management</p>
    <div class="test-controls">
      <button onclick="testReadWriteCycle()">Run Test</button>
      <button onclick="testMultipleCycles()">Multiple Cycles (5x)</button>
    </div>
    <div id="cycleResult"></div>
  </div>

  <div class="test-section">
    <h2>Test Log</h2>
    <button onclick="clearLog()">Clear Log</button>
    <button onclick="exportLog()">Export Log</button>
    <div id="testLog" class="log"></div>
  </div>

  <script>
    // Test statistics
    let stats = {
      total: 0,
      success: 0,
      failed: 0
    };

    // Test log
    let logEntries = [];

    // Sample test data
    const sampleData = {
      elementType: 'widget',
      widgetType: 'heading',
      settings: {
        title: 'Test Heading',
        header_size: 'h2'
      },
      content: '<h2>Test Heading</h2>'
    };

    // Log functions
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const entry = { timestamp, message, type };
      logEntries.push(entry);
      
      const logDiv = document.getElementById('testLog');
      const entryDiv = document.createElement('div');
      entryDiv.className = `log-entry ${type}`;
      entryDiv.textContent = `[${timestamp}] ${message}`;
      logDiv.appendChild(entryDiv);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function clearLog() {
      logEntries = [];
      document.getElementById('testLog').innerHTML = '';
      log('Log cleared', 'info');
    }

    function exportLog() {
      const logText = logEntries.map(e => `[${e.timestamp}] [${e.type.toUpperCase()}] ${e.message}`).join('\n');
      const blob = new Blob([logText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `clipboard-test-log-${Date.now()}.txt`;
      a.click();
      URL.revokeObjectURL(url);
      log('Log exported', 'success');
    }

    // Update statistics
    function updateStats() {
      document.getElementById('totalTests').textContent = stats.total;
      document.getElementById('successTests').textContent = stats.success;
      document.getElementById('failedTests').textContent = stats.failed;
      const rate = stats.total > 0 ? Math.round((stats.success / stats.total) * 100) : 0;
      document.getElementById('successRate').textContent = rate + '%';
    }

    function showResult(elementId, message, isSuccess) {
      const resultDiv = document.getElementById(elementId);
      resultDiv.className = `result ${isSuccess ? 'success' : 'error'}`;
      resultDiv.textContent = message;
      
      stats.total++;
      if (isSuccess) {
        stats.success++;
      } else {
        stats.failed++;
      }
      updateStats();
    }

    // Test 1: Basic Write
    async function testBasicWrite() {
      log('Starting basic clipboard write test...', 'info');
      try {
        await navigator.clipboard.writeText(JSON.stringify(sampleData, null, 2));
        showResult('basicWriteResult', 'âœ“ Basic write successful', true);
        log('Basic write test passed', 'success');
      } catch (error) {
        showResult('basicWriteResult', `âœ— Basic write failed: ${error.message}`, false);
        log(`Basic write test failed: ${error.message}`, 'error');
      }
    }

    async function testBasicWriteUnfocused() {
      log('Testing write without focus...', 'info');
      try {
        // Try to blur the window (may not work in all browsers)
        window.blur();
        await new Promise(resolve => setTimeout(resolve, 100));
        
        await navigator.clipboard.writeText(JSON.stringify(sampleData, null, 2));
        showResult('basicWriteResult', 'âœ“ Write without focus successful (focus was acquired)', true);
        log('Write without focus test passed', 'success');
      } catch (error) {
        showResult('basicWriteResult', `âœ— Write without focus failed: ${error.message}`, false);
        log(`Write without focus test failed: ${error.message}`, 'error');
      }
    }

    // Test 2: Retry Logic
    async function testRetryLogic() {
      log('Testing retry logic...', 'info');
      let attempts = 0;
      const maxAttempts = 3;
      
      async function writeWithRetry() {
        attempts++;
        try {
          await navigator.clipboard.writeText(JSON.stringify(sampleData, null, 2));
          return true;
        } catch (error) {
          if (attempts < maxAttempts) {
            log(`Attempt ${attempts} failed, retrying...`, 'warning');
            await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, attempts - 1)));
            return writeWithRetry();
          }
          throw error;
        }
      }
      
      try {
        await writeWithRetry();
        showResult('retryResult', `âœ“ Retry logic successful (${attempts} attempts)`, true);
        log(`Retry logic test passed after ${attempts} attempts`, 'success');
      } catch (error) {
        showResult('retryResult', `âœ— Retry logic failed after ${attempts} attempts: ${error.message}`, false);
        log(`Retry logic test failed: ${error.message}`, 'error');
      }
    }

    async function testMultipleRetries() {
      log('Testing multiple retry scenarios...', 'info');
      const results = [];
      
      for (let i = 0; i < 5; i++) {
        try {
          await navigator.clipboard.writeText(JSON.stringify({ ...sampleData, test: i }, null, 2));
          results.push(true);
          log(`Retry test ${i + 1}/5 passed`, 'success');
        } catch (error) {
          results.push(false);
          log(`Retry test ${i + 1}/5 failed: ${error.message}`, 'error');
        }
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      const successCount = results.filter(r => r).length;
      const isSuccess = successCount === 5;
      showResult('retryResult', `${isSuccess ? 'âœ“' : 'âœ—'} Multiple retries: ${successCount}/5 successful`, isSuccess);
    }

    // Test 3: Fallback Strategies
    async function testFallbackStrategies() {
      log('Testing fallback strategies...', 'info');
      const strategies = ['Clipboard API', 'execCommand', 'Textarea'];
      let successfulStrategy = null;
      
      // Try Clipboard API
      try {
        await navigator.clipboard.writeText(JSON.stringify(sampleData, null, 2));
        successfulStrategy = 'Clipboard API';
      } catch (error) {
        log('Clipboard API failed, trying execCommand...', 'warning');
        
        // Try execCommand
        try {
          const textarea = document.createElement('textarea');
          textarea.value = JSON.stringify(sampleData, null, 2);
          document.body.appendChild(textarea);
          textarea.select();
          const success = document.execCommand('copy');
          document.body.removeChild(textarea);
          
          if (success) {
            successfulStrategy = 'execCommand';
          }
        } catch (execError) {
          log('execCommand failed', 'error');
        }
      }
      
      if (successfulStrategy) {
        showResult('fallbackResult', `âœ“ Fallback successful using: ${successfulStrategy}`, true);
        log(`Fallback test passed using ${successfulStrategy}`, 'success');
      } else {
        showResult('fallbackResult', 'âœ— All fallback strategies failed', false);
        log('All fallback strategies failed', 'error');
      }
    }

    async function testExecCommandFallback() {
      log('Testing execCommand fallback...', 'info');
      try {
        const textarea = document.createElement('textarea');
        textarea.value = JSON.stringify(sampleData, null, 2);
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (success) {
          showResult('fallbackResult', 'âœ“ execCommand fallback successful', true);
          log('execCommand fallback test passed', 'success');
        } else {
          throw new Error('execCommand returned false');
        }
      } catch (error) {
        showResult('fallbackResult', `âœ— execCommand fallback failed: ${error.message}`, false);
        log(`execCommand fallback test failed: ${error.message}`, 'error');
      }
    }

    async function testTextareaFallback() {
      log('Testing textarea fallback...', 'info');
      try {
        const textarea = document.createElement('textarea');
        textarea.value = JSON.stringify(sampleData, null, 2);
        textarea.style.position = 'fixed';
        textarea.style.left = '0';
        textarea.style.top = '0';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        await navigator.clipboard.writeText(textarea.value);
        document.body.removeChild(textarea);
        
        showResult('fallbackResult', 'âœ“ Textarea fallback successful', true);
        log('Textarea fallback test passed', 'success');
      } catch (error) {
        showResult('fallbackResult', `âœ— Textarea fallback failed: ${error.message}`, false);
        log(`Textarea fallback test failed: ${error.message}`, 'error');
      }
    }

    // Test 4: Stress Test
    async function testRapidWrites() {
      log('Starting rapid writes test (10x)...', 'info');
      const results = [];
      const startTime = Date.now();
      
      for (let i = 0; i < 10; i++) {
        try {
          await navigator.clipboard.writeText(JSON.stringify({ ...sampleData, iteration: i }, null, 2));
          results.push(true);
        } catch (error) {
          results.push(false);
          log(`Rapid write ${i + 1} failed: ${error.message}`, 'error');
        }
      }
      
      const duration = Date.now() - startTime;
      const successCount = results.filter(r => r).length;
      const isSuccess = successCount === 10;
      
      showResult('stressResult', `${isSuccess ? 'âœ“' : 'âœ—'} Rapid writes: ${successCount}/10 successful in ${duration}ms`, isSuccess);
      log(`Rapid writes test completed: ${successCount}/10 in ${duration}ms`, isSuccess ? 'success' : 'error');
    }

    async function testLargeData() {
      log('Testing large data write...', 'info');
      const largeData = {
        ...sampleData,
        largeArray: Array(1000).fill(0).map((_, i) => ({ id: i, value: `Item ${i}` }))
      };
      
      try {
        const startTime = Date.now();
        await navigator.clipboard.writeText(JSON.stringify(largeData, null, 2));
        const duration = Date.now() - startTime;
        
        showResult('stressResult', `âœ“ Large data write successful (${duration}ms)`, true);
        log(`Large data test passed in ${duration}ms`, 'success');
      } catch (error) {
        showResult('stressResult', `âœ— Large data write failed: ${error.message}`, false);
        log(`Large data test failed: ${error.message}`, 'error');
      }
    }

    async function testConcurrentWrites() {
      log('Testing concurrent writes...', 'info');
      const promises = [];
      
      for (let i = 0; i < 5; i++) {
        promises.push(
          navigator.clipboard.writeText(JSON.stringify({ ...sampleData, concurrent: i }, null, 2))
            .then(() => ({ success: true, index: i }))
            .catch(error => ({ success: false, index: i, error: error.message }))
        );
      }
      
      const results = await Promise.all(promises);
      const successCount = results.filter(r => r.success).length;
      const isSuccess = successCount === 5;
      
      showResult('stressResult', `${isSuccess ? 'âœ“' : 'âœ—'} Concurrent writes: ${successCount}/5 successful`, isSuccess);
      log(`Concurrent writes test: ${successCount}/5 successful`, isSuccess ? 'success' : 'error');
    }

    // Test 5: Read/Write Cycle
    async function testReadWriteCycle() {
      log('Testing read/write cycle...', 'info');
      try {
        // Write
        const testData = { ...sampleData, timestamp: Date.now() };
        await navigator.clipboard.writeText(JSON.stringify(testData, null, 2));
        log('Write phase completed', 'info');
        
        // Small delay
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Read
        const clipboardText = await navigator.clipboard.readText();
        const readData = JSON.parse(clipboardText);
        
        // Verify
        if (readData.timestamp === testData.timestamp) {
          showResult('cycleResult', 'âœ“ Read/write cycle successful - data matches', true);
          log('Read/write cycle test passed', 'success');
        } else {
          throw new Error('Data mismatch');
        }
      } catch (error) {
        showResult('cycleResult', `âœ— Read/write cycle failed: ${error.message}`, false);
        log(`Read/write cycle test failed: ${error.message}`, 'error');
      }
    }

    async function testMultipleCycles() {
      log('Testing multiple read/write cycles (5x)...', 'info');
      const results = [];
      
      for (let i = 0; i < 5; i++) {
        try {
          const testData = { ...sampleData, cycle: i, timestamp: Date.now() };
          await navigator.clipboard.writeText(JSON.stringify(testData, null, 2));
          await new Promise(resolve => setTimeout(resolve, 50));
          
          const clipboardText = await navigator.clipboard.readText();
          const readData = JSON.parse(clipboardText);
          
          if (readData.cycle === i) {
            results.push(true);
            log(`Cycle ${i + 1}/5 passed`, 'success');
          } else {
            results.push(false);
            log(`Cycle ${i + 1}/5 failed: data mismatch`, 'error');
          }
        } catch (error) {
          results.push(false);
          log(`Cycle ${i + 1}/5 failed: ${error.message}`, 'error');
        }
      }
      
      const successCount = results.filter(r => r).length;
      const isSuccess = successCount === 5;
      showResult('cycleResult', `${isSuccess ? 'âœ“' : 'âœ—'} Multiple cycles: ${successCount}/5 successful`, isSuccess);
    }

    // Initialize
    log('Clipboard Focus Test Suite initialized', 'success');
    log('Ready to run tests', 'info');
  </script>
</body>
</html>
